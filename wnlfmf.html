<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ê±°ëŒ€ ìƒì¥ë¥¼ í”¼í•´ë¼! (UI ê°œì„  ë²„ì „)</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #1a0f00; font-family: 'Arial', sans-serif; touch-action: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        canvas { background: linear-gradient(to bottom, #3d2b1f, #1a0f00); box-shadow: 0 0 30px rgba(0,0,0,0.7); cursor: crosshair; }
        
        /* ê³µí†µ UI í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .ui-text { color: #ffdb4d; pointer-events: none; text-shadow: 2px 2px 4px #000; font-weight: bold; position: absolute; z-index: 10; }

        /* ìƒë‹¨ ì¤‘ì•™: ìŠ¤í…Œì´ì§€, ì‹œê°„, ì ìˆ˜ */
        #ui-top {
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 100%;
            font-size: 20px;
            display: flex;
            justify-content: center;
            gap: 20px; /* í•­ëª© ê°„ ê°„ê²© */
        }
        #score-val { color: #fff; font-size: 24px; }

        /* í•˜ë‹¨ ì¤‘ì•™: ìƒëª… í‘œì‹œ */
        #ui-bottom {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 22px;
            background: rgba(0,0,0,0.3);
            padding: 5px 20px;
            border-radius: 20px;
        }

        /* ì‹œì‘ ì˜¤ë²„ë ˆì´ */
        #start-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 200; cursor: pointer; }
        
        /* ê²Œì„ ì˜¤ë²„ ë©”ì‹œì§€ */
        #msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff4444; font-size: 45px; font-weight: bold; text-align: center; display: none; cursor: pointer; background: rgba(0,0,0,0.95); padding: 40px; border-radius: 20px; border: 4px solid #ffdb4d; z-index: 100; }
        
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-top" class="ui-text">
        <div>STAGE: <span id="stage">1</span></div>
        <div>SCORE: <span id="score-val">0</span></div>
        <div>TIME: <span id="timer">40</span>s</div>
    </div>

    <div id="ui-bottom" class="ui-text">
        LIVES: <span id="lives-heart">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</span>
    </div>

    <div id="start-overlay" onclick="startGame()">
        <h1 style="color: #ffdb4d; font-size: 2.5em; margin-bottom: 10px;">ê±°ëŒ€ ìƒì¥ë¥¼ í”¼í•´ë¼!</h1>
        <p style="font-size: 1.2em; animation: blink 1.5s infinite;">í™”ë©´ì„ í´ë¦­í•˜ì—¬ ê²Œì„ ì‹œì‘</p>
        <div style="font-size: 14px; color: #aaa; margin-top: 30px; text-align: center; line-height: 1.6;">
            [ì¡°ì‘ ë°©ë²•]<br>
            PC: ì¢Œìš° ë°©í–¥í‚¤ | ëª¨ë°”ì¼: í™”ë©´ ë“œë˜ê·¸<br>
            ğŸ””: ê³ ì–‘ì´ ì†Œí™˜ | ğŸ§€: ì¹˜ì¦ˆ ë³µêµ¬ | ğŸ’: ë³´ë„ˆìŠ¤ ì ìˆ˜
        </div>
    </div>

    <div id="msg" onclick="resetGame()">CHEESE EATEN!<br><span style="font-size:22px; color:white; font-weight:normal;">ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ í´ë¦­</span></div>
</div>

<script>
    // --- ì‚¬ìš´ë“œ ì—”ì§„ ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playTone(freq, type, duration, vol = 0.1) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    const sounds = {
        hit: () => playTone(150, 'sine', 0.2, 0.3),
        bell: () => { playTone(880, 'triangle', 0.5, 0.2); setTimeout(() => playTone(1046, 'triangle', 0.5, 0.1), 100); },
        heal: () => { [440, 554, 659].forEach((f, i) => setTimeout(() => playTone(f, 'sine', 0.4, 0.1), i * 100)); },
        gem: () => playTone(1320, 'sine', 0.1, 0.1),
        gameOver: () => { [300, 200, 150].forEach((f, i) => setTimeout(() => playTone(f, 'sawtooth', 0.6, 0.1), i * 200)); }
    };

    let bgmInterval;
    function startBgm() {
        const notes = [130, 164, 196, 164];
        let step = 0;
        bgmInterval = setInterval(() => {
            if (!gameOver && gameActive) {
                playTone(notes[step % notes.length], 'triangle', 0.4, 0.05);
                step++;
            }
        }, 500);
    }

    // --- ê²Œì„ ë¡œì§ ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = { 
        stage: document.getElementById('stage'), 
        score: document.getElementById('score-val'), 
        timer: document.getElementById('timer'), 
        lives: document.getElementById('lives-heart'), 
        msg: document.getElementById('msg'), 
        overlay: document.getElementById('start-overlay') 
    };

    let canvasW, canvasH, stage = 1, timeLeft = 40, lives = 5, score = 0, gameOver = false, gameActive = false;
    const player = { x: 0, y: 0, size: 50, bites: [] }; 
    let enemies = [], items = [], gems = [], lastTime = 0, spawnTimer = 0, itemTimer = 0;
    let cat = { active: false, timer: 0, x: 0, y: 0, size: 75 };
    const mouseIcons = ['ğŸ­', 'ğŸ€', 'ğŸ¹', 'ğŸ¦‡'];
    const gemColors = ['#FF3E3E', '#3EADFF', '#FFD700', '#44FF44', '#E044FF'];

    function resize() {
        canvasW = window.innerWidth > 600 ? 500 : window.innerWidth;
        canvasH = window.innerHeight;
        canvas.width = canvasW; canvas.height = canvasH;
        player.x = canvasW / 2 - player.size / 2; player.y = canvasH - 120;
    }
    window.addEventListener('resize', resize); resize();

    function startGame() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        ui.overlay.style.display = 'none';
        gameActive = true;
        startBgm();
        requestAnimationFrame(loop);
    }

    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        player.x = e.touches[0].clientX - rect.left - player.size / 2;
    }, { passive: false });

    function update(dt) {
        if (gameOver || !gameActive) return;

        if (keys['ArrowLeft'] && player.x > 0) player.x -= 9;
        if (keys['ArrowRight'] && player.x < canvasW - player.size) player.x += 9;
        if (player.x < 0) player.x = 0;
        if (player.x > canvasW - player.size) player.x = canvasW - player.size;

        if (cat.active) {
            cat.timer -= dt;
            if (enemies.length > 0) { cat.x += (enemies[0].x - cat.x) * 0.15; cat.y += (enemies[0].y - cat.y) * 0.15; }
            else { cat.y = canvasH - 250; cat.x += (player.x - cat.x) * 0.05; }
            if (cat.timer <= 0) cat.active = false;
        }

        spawnTimer += dt;
        if (spawnTimer > 1000 / (0.8 + stage * 0.4)) {
            const size = player.size * (1.3 + Math.random() * (0.6 + stage * 0.2));
            enemies.push({ x: Math.random() * (canvasW - size), y: -size, size, speed: (2.5 + Math.random() * 2) + (stage * 0.6), icon: mouseIcons[Math.floor(Math.random() * mouseIcons.length)], hue: Math.floor(Math.random() * 360) });
            spawnTimer = 0;
        }

        enemies.forEach((en, i) => {
            en.y += en.speed;
            if (cat.active && Math.abs(en.x - cat.x) < 80 && Math.abs(en.y - cat.y) < 80) {
                enemies.splice(i, 1); score += 10; updateUI(); sounds.hit(); return;
            }
            if (en.x + 15 < player.x + player.size && en.x + en.size - 15 > player.x && en.y + 15 < player.y + player.size && en.y + en.size - 15 > player.y) {
                enemies.splice(i, 1); lives--; player.bites.push({ rx: Math.random() * player.size, ry: Math.random() * player.size });
                sounds.hit(); updateUI(); if (lives <= 0) endGame();
            }
            if (en.y > canvasH) enemies.splice(i, 1);
        });

        itemTimer += dt;
        if (itemTimer > 4000) {
            const rand = Math.random();
            if (rand < 0.2) items.push({ x: Math.random() * (canvasW-35), y: -35, type: 'bell', icon: 'ğŸ””' });
            else if (rand < 0.45) items.push({ x: Math.random() * (canvasW-35), y: -35, type: 'heal', icon: 'ğŸ§€' });
            else gems.push({ x: Math.random() * (canvasW-25), y: -25, color: gemColors[Math.floor(Math.random()*5)] });
            itemTimer = 0;
        }

        items.forEach((it, i) => {
            it.y += 3.5;
            if (it.x < player.x + player.size && it.x + 35 > player.x && it.y < player.y + player.size && it.y + 35 > player.y) {
                if (it.type === 'bell') { cat.active = true; cat.timer = 10000; cat.x = player.x; cat.y = player.y - 150; sounds.bell(); }
                if (it.type === 'heal') { if (lives < 5) { lives++; player.bites.pop(); } sounds.heal(); }
                items.splice(i, 1); updateUI();
            }
            if (it.y > canvasH) items.splice(i, 1);
        });

        gems.forEach((gm, i) => {
            gm.y += 4.5;
            if (gm.x < player.x + player.size && gm.x + 25 > player.x && gm.y < player.y + player.size && gm.y + 25 > player.y) {
                score += 100; gems.splice(i, 1); sounds.gem(); updateUI();
            }
            if (gm.y > canvasH) gems.splice(i, 1);
        });

        timeLeft -= dt / 1000;
        if (timeLeft <= 0) { stage++; timeLeft = 40; sounds.heal(); updateUI(); }
        ui.timer.innerText = Math.ceil(timeLeft);
    }

    function updateUI() { 
        ui.stage.innerText = stage; 
        ui.score.innerText = score; 
        ui.lives.innerText = 'â¤ï¸'.repeat(lives); 
    }

    function draw() {
        ctx.clearRect(0, 0, canvasW, canvasH);
        
        // ì¹˜ì¦ˆ
        ctx.save();
        ctx.font = `${player.size}px Arial`;
        ctx.fillText('ğŸ§€', player.x, player.y + player.size);
        ctx.globalCompositeOperation = 'destination-out';
        player.bites.forEach(b => { ctx.beginPath(); ctx.arc(player.x + b.rx, player.y + b.ry, 14, 0, Math.PI * 2); ctx.fill(); });
        ctx.restore();

        // ê³ ì–‘ì´
        if (cat.active) {
            ctx.save(); ctx.shadowBlur = 25; ctx.shadowColor = "#ffdb4d";
            ctx.font = `${cat.size}px Arial`; ctx.fillText('ğŸ±', cat.x, cat.y); ctx.restore();
        }

        // ìƒì¥
        enemies.forEach(en => {
            ctx.save(); ctx.filter = `hue-rotate(${en.hue}deg)`;
            ctx.font = `${en.size}px Arial`; ctx.fillText(en.icon, en.x, en.y + en.size); ctx.restore();
        });

        // ì•„ì´í…œ & ë³´ì„
        items.forEach(it => { ctx.font = `35px Arial`; ctx.fillText(it.icon, it.x, it.y + 35); });
        gems.forEach(gm => {
            ctx.save(); ctx.fillStyle = gm.color; ctx.shadowBlur = 10; ctx.shadowColor = gm.color;
            ctx.beginPath(); ctx.moveTo(gm.x+12, gm.y); ctx.lineTo(gm.x+24, gm.y+12); ctx.lineTo(gm.x+12, gm.y+24); ctx.lineTo(gm.x, gm.y+12); ctx.fill(); ctx.restore();
        });
    }

    function loop(t) {
        if (!lastTime) lastTime = t;
        const dt = t - lastTime;
        lastTime = t;
        update(dt); draw();
        if (gameActive) requestAnimationFrame(loop);
    }

    function endGame() { gameOver = true; gameActive = false; ui.msg.style.display = 'block'; sounds.gameOver(); clearInterval(bgmInterval); }
    
    function resetGame() {
        stage = 1; timeLeft = 40; lives = 5; score = 0; enemies = []; items = []; gems = []; player.bites = [];
        gameOver = false; gameActive = true; cat.active = false;
        ui.msg.style.display = 'none'; updateUI();
        lastTime = 0; startBgm(); requestAnimationFrame(loop);
    }
</script>
</body>
</html>